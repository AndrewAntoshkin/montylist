/**
 * Промпты v4 — для PySceneDetect
 * 
 * Идентичны v3, но предназначены для работы с более точными таймкодами
 * от PySceneDetect (AdaptiveDetector)
 */

/**
 * Форматирует персонажей из сценария для промпта
 */
export function formatCharactersForPromptV4(
  characters: Array<{ name: string; gender?: string; description?: string; dialogueCount?: number }>
): string {
  if (!characters || characters.length === 0) return '';
  
  // Главные персонажи (5+ реплик)
  const main = characters.filter(c => (c.dialogueCount || 0) >= 5);
  // Второстепенные (2-4 реплики)
  const secondary = characters.filter(c => (c.dialogueCount || 0) >= 2 && (c.dialogueCount || 0) < 5);
  
  const lines: string[] = [
    '═══════════════════════════════════════════════════════',
    '🎭 ПЕРСОНАЖИ ФИЛЬМА',
    '═══════════════════════════════════════════════════════',
    '',
    '⚠️ КРИТИЧЕСКИ ВАЖНО ДЛЯ ИМЁН:',
    '',
    '1. ИСПОЛЬЗУЙ КОРОТКИЕ ФОРМЫ ИМЁН (как в жизни):',
    '   • ГАЛЯ (не "Галина")',
    '   • ТАНЯ (не "Татьяна")',
    '   • ТОМА (не "Тамара")',
    '   • БЭЛЛА, ШУРОЧКА, ЛЮДАСЯ, СВЕТА — как в списке ниже',
    '',
    '2. ЗАПРЕЩЕНО использовать ПРОФЕССИИ вместо имён:',
    '   • НЕ "Менеджер" → используй имя (например ИОСИФ)',
    '   • НЕ "Косметолог" → используй имя (например ТОМА)',
    '   • НЕ "Официантка" → используй имя',
    '',
    '3. КАЖДАЯ РЕПЛИКА ДОЛЖНА ИМЕТЬ ИМЯ СПИКЕРА!',
    '   Даже если персонаж говорит за кадром — укажи "ИМЯ ЗК"',
  ];
  
  if (main.length > 0) {
    lines.push('');
    lines.push('👥 ГЛАВНЫЕ ПЕРСОНАЖИ:');
    for (const c of main.slice(0, 12)) {
      const gender = c.gender === 'female' ? '👩' : c.gender === 'male' ? '👨' : '👤';
      let desc = c.description || '';
      if (desc.length > 150) desc = desc.slice(0, 150) + '...';
      lines.push(`   ${gender} ${c.name.toUpperCase()}${desc ? ': ' + desc : ''}`);
    }
  }
  
  if (secondary.length > 0) {
    lines.push('');
    lines.push('👥 ВТОРОСТЕПЕННЫЕ:');
    for (const c of secondary.slice(0, 8)) {
      const gender = c.gender === 'female' ? '👩' : c.gender === 'male' ? '👨' : '👤';
      const desc = c.description ? `: ${c.description.slice(0, 80)}` : '';
      lines.push(`   ${gender} ${c.name.toUpperCase()}${desc}`);
    }
  }
  
  // Собираем все имена для быстрой проверки
  const allNames = [...main, ...secondary].map(c => c.name.toUpperCase()).join(', ');
  lines.push('');
  lines.push(`📋 Разрешённые имена: ${allNames}`);
  lines.push('═══════════════════════════════════════════════════════');
  
  return lines.join('\n');
}

/**
 * ОСНОВНОЙ ПРОМПТ v4 — для PySceneDetect
 * 
 * PySceneDetect даёт более точные таймкоды — AI описывает что видит и слышит.
 */
export function createPromptV4(
  scenes: Array<{ start_timecode: string; end_timecode: string }>,
  characterRegistry: string = ''
): string {
  const sceneList = scenes
    .map((s, i) => `${i + 1}. ${s.start_timecode} - ${s.end_timecode}`)
    .join('\n');

  return `Создай монтажный лист для ${scenes.length} планов.

ТАЙМКОДЫ ФИКСИРОВАНЫ (от PySceneDetect) — не меняй их, просто опиши каждый:

${sceneList}
${characterRegistry ? `\n${characterRegistry}\n` : ''}
ДЛЯ КАЖДОГО ПЛАНА НАПИШИ (используй ТОЧНО эти таймкоды из списка!):

**START_TIMECODE - END_TIMECODE**
План: [Кр./Ср./Общ./Деталь] [+ НДП если есть титры]
Содержание: [Кто в кадре, что делает. Если титры — укажи текст]
Диалоги: [ИМЯ (имя на отдельной строке)
текст реплики] или "Музыка"

ПРИМЕР:
**00:01:06:13 - 00:01:09:09**
План: Ср. НДП
Содержание: Женщина идёт по салону.
Титр: Анна – Мария Иванова
Диалоги: АННА
Проходите, присаживайтесь.

**00:01:09:09 - 00:01:12:15**
План: Кр.
Содержание: Клиентка садится на кушетку.
Диалоги: КЛИЕНТКА
Спасибо.

ПРАВИЛА:

1. ✅ ДИАЛОГИ — КАЖДАЯ РЕПЛИКА С ИМЕНЕМ!
   - ВСЕГДА пиши ИМЯ перед репликой
   - Формат: ИМЯ (отдельная строка), потом текст
   - Если нет речи: "Музыка" (БЕЗ скобок, БЕЗ описаний звуков)

2. 🎤 ЗА КАДРОМ (ЗК) — КРИТИЧЕСКИ ВАЖНО!
   Когда персонаж ГОВОРИТ, но его НЕ видно в кадре — пиши "ИМЯ ЗК":
   
   ✅ ПРИМЕРЫ когда нужен ЗК:
   • Камера на слушающем (Тома в кадре), а говорит ГАЛЯ → "ГАЛЯ ЗК"
   • Камера на реакции (Юсеф смотрит), а говорит ГАЛЯ → "ГАЛЯ ЗК"
   • Камера на предмете/детали, а голос продолжается → "ИМЯ ЗК"
   
   🔍 КАК ОПРЕДЕЛИТЬ:
   • Слышен голос? → Кто говорил в ПРЕДЫДУЩЕМ плане?
   • Камера сменилась на другого персонажа, но голос тот же? → Добавь "ЗК"
   • Реплика началась в одном плане и продолжается в следующем → "ЗК"

3. ❌ ЗАПРЕЩЕНО:
   - [Шаги], [Вздох], [Шум], [Пауза] — НЕ ПИШИ такое! 
   - Реплики без имени — КАЖДАЯ реплика имеет автора
   - "Менеджер", "Косметолог", "Официантка" — ТОЛЬКО ИМЕНА из списка

4. 📝 ИМЕНА — КОРОТКИЕ ФОРМЫ:
   - ГАЛЯ (не "Галина")
   - ТАНЯ (не "Татьяна") 
   - ТОМА, БЭЛЛА, ШУРОЧКА, ЛЮДАСЯ, СВЕТА — как в списке
   - ИОСИФ (не "Менеджер")

5. 🎬 ТИПЫ ПЛАНОВ — короткие формы:
   - Кр., Ср., Общ., Деталь
   - НДП, Ср. НДП, Кр. НДП — для титров

6. Описывай ВСЕ ${scenes.length} планов!`;
}

/**
 * Промпт для НАЧАЛА видео (первый чанк)
 */
export function createOpeningPromptV4(
  scenes: Array<{ start_timecode: string; end_timecode: string }>,
  characterRegistry: string = ''
): string {
  const sceneList = scenes
    .map((s, i) => `${i + 1}. ${s.start_timecode} - ${s.end_timecode}`)
    .join('\n');

  return `Создай монтажный лист для НАЧАЛА видео.

PySceneDetect нашёл ${scenes.length} склеек:
${sceneList}
${characterRegistry ? `\n${characterRegistry}\n` : ''}
═══════════════════════════════════════════════════════
🎬 ТЫ ВИДИШЬ ВИДЕО — ОПРЕДЕЛИ ГДЕ ЗАСТАВКА!
═══════════════════════════════════════════════════════

PySceneDetect нашёл много склеек, но НЕ описывай каждую отдельно!
ТЫ должен САМИ определить структуру начала видео.

**СМОТРИ НА ВИДЕО и найди:**

1. **ЛОГОТИП** (обычно первые 2-6 секунд)
   - Статичный логотип студии/канала
   - Может быть анимированный
   → Это ОДИН план

2. **ЗАСТАВКА** (может быть 20 сек или 2 минуты — зависит от видео!)
   Признаки заставки:
   - 🎵 Только МУЗЫКА (нет диалогов персонажей)
   - 📝 Титры с именами актёров и создателей
   - 🎬 Рапид, нарезка, стилизованные кадры
   - 👤 Короткие "визитки" персонажей (позируют, улыбаются)
   - 🎭 Название фильма/сериала
   → Это ОДИН план (объедини все склейки!)

3. **КОНЕЦ ЗАСТАВКИ** — начинается когда:
   - ✅ Персонаж ГОВОРИТ (первый диалог)
   - ✅ Начинается СЮЖЕТ (взаимодействие персонажей)
   - ✅ Исчезает музыка заставки
   - ✅ Меняется стиль съёмки (обычные сцены вместо нарезки)
   → После этого каждая склейка = отдельный план

**ТВОЯ ЗАДАЧА:**
1. Посмотри видео
2. Определи где ВИЗУАЛЬНО заканчивается заставка
3. Объедини все склейки заставки в ОДИН план
4. После заставки — обычные планы по склейкам

⚠️ ФОРМАТ ТАЙМКОДОВ: ВСЕГДА 00:MM:SS:FF (часы:минуты:секунды:кадры)
   ✅ Правильно: 00:01:06:13
   ❌ Неправильно: 01:06:13 (пропущены часы!)

═══════════════════════════════════════════════════════
✅ ФОРМАТ ОТВЕТА:
═══════════════════════════════════════════════════════

**[НАЧАЛО ЛОГОТИПА] - [КОНЕЦ ЛОГОТИПА]**
План: НДП
Содержание: Логотип. [Название студии/канала].
Диалоги: Музыка

**[КОНЕЦ ЛОГОТИПА] - [КОНЕЦ ЗАСТАВКИ — где начинается первый диалог!]**
План: Ср. НДП
Содержание: Заставка. [Опиши ВСЁ что видишь: лица персонажей, их действия, предметы, визуальный стиль]
Титр: [Каждый титр на новой строке — имена актёров, режиссёров, продюсеров]
Название: [Название фильма/сериала если есть]
Диалоги: Музыка

**[КОНЕЦ ЗАСТАВКИ] - [следующая склейка]**
План: [Кр./Ср./Общ.] [+ НДП если есть титры]
Содержание: [Первая сцена с диалогом — опиши действие]
Диалоги: [ИМЯ ПЕРСОНАЖА]
[Первая реплика]

... далее каждая склейка = отдельный план ...

═══════════════════════════════════════════════════════
❌ НЕПРАВИЛЬНО (НЕ делай так!):
═══════════════════════════════════════════════════════

❌ Описывать КАЖДУЮ склейку заставки отдельно
❌ Заканчивать заставку там, где ещё нет диалогов
❌ Планы типа "Сюзанна улыбается", "Бэлла с веревками" — если это ещё заставка,
   объедини всё в ОДИН план!
   
**КАК ПОНЯТЬ ЧТО ЗАСТАВКА ЕЩЁ ИДЁТ:**
- Слышна только музыка заставки?
- Есть титры с именами?
- Персонажи "позируют" а не взаимодействуют?
→ Это всё ещё ЗАСТАВКА, НЕ разбивай!

═══════════════════════════════════════════════════════
📝 КРИТИЧЕСКИЕ ПРАВИЛА:
═══════════════════════════════════════════════════════

1. **ОБЪЕДИНЯЙ заставку в ОДИН план (от логотипа до первого диалога)!**

2. ДИАЛОГИ — КАЖДАЯ РЕПЛИКА С ИМЕНЕМ:
   ✅ ТОМА
   Проходите, присаживайтесь.

3. ИМЕНА — КОРОТКИЕ ФОРМЫ:
   • ГАЛЯ (не "Галина"), ТАНЯ (не "Татьяна")
   • ТОМА, БЭЛЛА, ШУРОЧКА, ЛЮДАСЯ — как в списке

4. ❌ ЗАПРЕЩЕНО:
   • [Шаги], [Вздох], [Шум] — НЕ ПИШИ!
   • Если нет речи — просто "Музыка"

5. ТИП ПЛАНА для заставки: "Нарезка" (много коротких кадров)

═══════════════════════════════════════════════════════

⚠️ ОЖИДАЕМАЯ СТРУКТУРА:
   • План 1: Логотип (несколько секунд)
   • План 2: Заставка (пока не начнётся первый диалог!) — ВСЕ титры и лица в ОДНОМ плане!
   • Планы 3+: Обычные планы (каждая склейка после начала диалогов)
   
Количество планов зависит от длины заставки — определи её ВИЗУАЛЬНО!`;
}

/**
 * Промпт для чанка с контекстом
 */
export function createChunkPromptV4(
  scenes: Array<{ start_timecode: string; end_timecode: string }>,
  chunkIndex: number,
  totalChunks: number,
  isFirstChunk: boolean,
  isLastChunk: boolean,
  characterRegistry: string = ''
): string {
  // Для первого чанка используем специальный промпт
  if (isFirstChunk && chunkIndex === 0) {
    return createOpeningPromptV4(scenes, characterRegistry);
  }
  
  // Для обычных чанков — стандартный промпт
  let prompt = createPromptV4(scenes, characterRegistry);
  
  // Добавляем информацию о позиции
  if (totalChunks > 1) {
    prompt += `\n\nЭто часть ${chunkIndex + 1} из ${totalChunks}.`;
  }
  
  return prompt;
}

/**
 * Нормализует таймкод в формат HH:MM:SS:FF
 * Исправляет частую ошибку AI: 01:06:13:00 → 00:01:06:13
 * (AI пишет MM:SS:FF:00 вместо 00:MM:SS:FF)
 */
function normalizeTimecode(tc: string): string {
  if (!tc) return tc;
  
  const parts = tc.split(':');
  if (parts.length !== 4) return tc;
  
  const [p0, p1, p2, p3] = parts.map(Number);
  
  // Если первая часть > 0 но < 60, и это явно не часы (видео короче часа),
  // то AI скорее всего написал MM:SS:FF:00 вместо 00:MM:SS:FF
  // Проверяем: если p0 < 60 и p0 > 0 и (p3 === 0 или p1 > 23)
  // то это MM:SS:FF:00 формат
  
  if (p0 > 0 && p0 < 60 && p3 === 0) {
    // Проверяем что p1 похоже на секунды (0-59) и p2 на кадры (0-24)
    if (p1 >= 0 && p1 < 60 && p2 >= 0 && p2 < 30) {
      // Преобразуем MM:SS:FF:00 → 00:MM:SS:FF
      const corrected = `00:${String(p0).padStart(2, '0')}:${String(p1).padStart(2, '0')}:${String(p2).padStart(2, '0')}`;
      console.log(`   🔧 Timecode fix: ${tc} → ${corrected}`);
      return corrected;
    }
  }
  
  return tc;
}

/**
 * Парсер ответа v4 — markdown формат (идентичен v3)
 */
export function parseResponseV4(response: string): Array<{
  start_timecode: string;
  end_timecode: string;
  plan_type: string;
  description: string;
  dialogues: string;
}> {
  const results: Array<{
    start_timecode: string;
    end_timecode: string;
    plan_type: string;
    description: string;
    dialogues: string;
  }> = [];
  
  // Разбиваем по блокам, начинающимся с **таймкод - таймкод**
  const blocks = response.split(/\*\*(\d{2}:\d{2}:\d{2}(?::\d{2})?)\s*[-–—]\s*(\d{2}:\d{2}:\d{2}(?::\d{2})?)\*\*/);
  
  for (let i = 1; i < blocks.length; i += 3) {
    let startTimecode = blocks[i];
    let endTimecode = blocks[i + 1];
    const content = blocks[i + 2] || '';
    
    // Нормализуем таймкоды — добавляем :00 кадров если нет
    if (startTimecode && startTimecode.split(':').length === 3) {
      startTimecode += ':00';
    }
    if (endTimecode && endTimecode.split(':').length === 3) {
      endTimecode += ':00';
    }
    
    // Исправляем короткий формат: 01:06:13:00 → 00:01:06:13
    // AI иногда пишет MM:SS:FF вместо HH:MM:SS:FF
    startTimecode = normalizeTimecode(startTimecode);
    endTimecode = normalizeTimecode(endTimecode);
    
    if (!startTimecode || !endTimecode) continue;
    
    // Парсим содержимое блока
    const planMatch = content.match(/План:\s*(.+?)(?:\n|$)/i);
    const contentMatch = content.match(/Содержание:\s*([\s\S]*?)(?=Диалоги:|$)/i);
    const dialoguesMatch = content.match(/Диалоги:\s*([\s\S]*?)(?=\*\*|$)/i);
    
    results.push({
      start_timecode: startTimecode.trim(),
      end_timecode: endTimecode.trim(),
      plan_type: planMatch ? planMatch[1].trim() : 'Ср.',
      description: contentMatch ? contentMatch[1].trim() : '',
      dialogues: dialoguesMatch ? dialoguesMatch[1].trim() : 'Музыка',
    });
  }
  
  return results;
}

