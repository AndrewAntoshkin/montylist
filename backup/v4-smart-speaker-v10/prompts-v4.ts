/**
 * Промпты v4 — для PySceneDetect
 * 
 * Чистый, профессиональный промпт без эмодзи и капса.
 * Точные инструкции для Gemini.
 */

/**
 * Форматирует персонажей из сценария для промпта
 */
export function formatCharactersForPromptV4(
  characters: Array<{ name: string; gender?: string; description?: string; dialogueCount?: number }>
): string {
  if (!characters || characters.length === 0) return '';
  
  // Главные персонажи (5+ реплик)
  const main = characters.filter(c => (c.dialogueCount || 0) >= 5);
  // Второстепенные (2-4 реплики)
  const secondary = characters.filter(c => (c.dialogueCount || 0) >= 2 && (c.dialogueCount || 0) < 5);
  
  const lines: string[] = [
    '---',
    'ПЕРСОНАЖИ ФИЛЬМА',
    '---',
    '',
    'Правила определения персонажей:',
    '',
    '1. Используй только имена из списка ниже.',
    '2. Смотри титры в видео — там указаны имена актёров и персонажей.',
    '3. Сравни внешность с описаниями в списке.',
    '4. Если не можешь определить имя — используй роль:',
    '   - Косметолог, Мастер маникюра, Официант, Врач, Менеджер',
    '5. Каждая реплика должна иметь автора.',
    '6. За кадром — добавь ЗК (например: ГАЛЯ ЗК)',
    '',
    'Как определить кто говорит:',
    '- Смотри чьи губы двигаются синхронно с речью',
    '- Если губы не двигаются у человека в кадре — это ЗК',
    '',
    'Голос за кадром (ЗК):',
    '- Камера на одном персонаже, а говорит другой',
    '- Пример: в кадре Галя (молчит), голос Томы — пиши ТОМА ЗК',
  ];
  
  if (main.length > 0) {
    lines.push('');
    lines.push('Главные персонажи:');
    for (const c of main.slice(0, 12)) {
      const gender = c.gender === 'female' ? '(ж)' : c.gender === 'male' ? '(м)' : '';
      let desc = c.description || '';
      if (desc.length > 150) desc = desc.slice(0, 150) + '...';
      lines.push(`- ${c.name.toUpperCase()} ${gender}${desc ? ': ' + desc : ''}`);
    }
  }
  
  if (secondary.length > 0) {
    lines.push('');
    lines.push('Второстепенные персонажи:');
    for (const c of secondary.slice(0, 8)) {
      const gender = c.gender === 'female' ? '(ж)' : c.gender === 'male' ? '(м)' : '';
      const desc = c.description ? `: ${c.description.slice(0, 80)}` : '';
      lines.push(`- ${c.name.toUpperCase()} ${gender}${desc}`);
    }
  }
  
  // Собираем все имена для быстрой проверки
  const allNames = [...main, ...secondary].map(c => c.name.toUpperCase()).join(', ');
  lines.push('');
  lines.push('Разрешённые имена:');
  lines.push(allNames);
  lines.push('');
  lines.push('Запрещено использовать имена не из этого списка.');
  lines.push('---');
  
  return lines.join('\n');
}

/**
 * Основной промпт v4 — для PySceneDetect
 */
export function createPromptV4(
  scenes: Array<{ start_timecode: string; end_timecode: string }>,
  characterRegistry: string = ''
): string {
  const sceneList = scenes
    .map((s, i) => `${i + 1}. ${s.start_timecode} - ${s.end_timecode}`)
    .join('\n');

  return `Создай монтажный лист для ${scenes.length} планов.

Таймкоды фиксированы (от PySceneDetect) — не меняй их, просто опиши каждый:

${sceneList}
${characterRegistry ? `\n${characterRegistry}\n` : ''}
Для каждого плана напиши (используй точно эти таймкоды из списка):

**START_TIMECODE - END_TIMECODE**
План: [Кр./Ср./Общ./Деталь] [+ НДП если есть титры]
Содержание: [Кто в кадре, что делает. Если титры — укажи текст]
Диалоги: [ИМЯ (имя на отдельной строке)
текст реплики] или "Музыка"

Пример:

**00:01:06:13 - 00:01:09:09**
План: Ср. НДП
Содержание: Женщина идёт по салону.
Титр: Анна – Мария Иванова
Диалоги: АННА
Проходите, присаживайтесь.

**00:01:09:09 - 00:01:12:15**
План: Кр.
Содержание: Клиентка садится на кушетку.
Диалоги: КЛИЕНТКА
Спасибо.

Правила:

1. Диалоги — каждая реплика с именем.
   - Всегда пиши имя перед репликой
   - Формат: ИМЯ (отдельная строка), потом текст
   - Если нет речи: "Музыка" (без скобок, без описаний звуков)

2. Короткие реплики — не пропускай!
   - Даже планы 1-2 секунды могут содержать фразы: "Что?", "Ага", "По...", "Минуточку"
   - Слушай внимательно — если слышна речь, пиши её
   - Не пиши "Музыка" если есть хоть одно слово

3. За кадром (ЗК) — критически важно.
   Когда персонаж говорит, но его не видно в кадре — пиши "ИМЯ ЗК":
   
   Примеры когда нужен ЗК:
   - Камера на слушающем (Тома в кадре), а говорит Галя — ГАЛЯ ЗК
   - Камера на реакции (Юсеф смотрит), а говорит Галя — ГАЛЯ ЗК
   - Камера на предмете/детали, а голос продолжается — ИМЯ ЗК
   
   Как определить:
   - Слышен голос? Кто говорил в предыдущем плане?
   - Камера сменилась на другого персонажа, но голос тот же? Добавь ЗК
   - Реплика началась в одном плане и продолжается в следующем — ЗК

4. Запрещено:
   - [Шаги], [Вздох], [Шум], [Пауза] — не пиши такое
   - Реплики без имени — каждая реплика имеет автора

5. Имена — короткие формы:
   - ГАЛЯ (не "Галина")
   - ТАНЯ (не "Татьяна") 
   - ТОМА, БЭЛЛА, ШУРОЧКА, ЛЮДАСЯ, СВЕТА — как в списке
   - ИОСИФ (не "Менеджер")

6. Типы планов — короткие формы:
   - Кр., Ср., Общ., Деталь
   - НДП, Ср. НДП, Кр. НДП — для титров

Опиши все ${scenes.length} планов.`;
}

/**
 * Промпт для начала видео (первый чанк)
 */
export function createOpeningPromptV4(
  scenes: Array<{ start_timecode: string; end_timecode: string }>,
  characterRegistry: string = ''
): string {
  const sceneList = scenes
    .map((s, i) => `${i + 1}. ${s.start_timecode} - ${s.end_timecode}`)
    .join('\n');

  return `Создай монтажный лист для начала видео.

PySceneDetect нашёл ${scenes.length} склеек:
${sceneList}
${characterRegistry ? `\n${characterRegistry}\n` : ''}
---
Ты видишь видео — определи где заставка.
---

PySceneDetect нашёл много склеек, но не описывай каждую отдельно.
Ты должен сам определить структуру начала видео.

Смотри на видео и найди:

1. Логотип (обычно первые 2-6 секунд)
   - Статичный логотип студии/канала
   - Может быть анимированный
   - Это один план

2. Заставка (может быть 20 сек или 2 минуты — зависит от видео)
   Признаки заставки:
   - Только музыка (нет диалогов персонажей)
   - Титры с именами актёров и создателей
   - Рапид, нарезка, стилизованные кадры
   - Короткие "визитки" персонажей (позируют, улыбаются)
   - Название фильма/сериала
   - Это один план (объедини все склейки)

3. Конец заставки — начинается когда:
   - Персонаж говорит (первый диалог)
   - Начинается сюжет (взаимодействие персонажей)
   - Исчезает музыка заставки
   - Меняется стиль съёмки (обычные сцены вместо нарезки)
   - После этого каждая склейка = отдельный план

Твоя задача:
1. Посмотри видео
2. Определи где визуально заканчивается заставка
3. Объедини все склейки заставки в один план
4. После заставки — обычные планы по склейкам

Формат таймкодов: всегда 00:MM:SS:FF (часы:минуты:секунды:кадры)
   Правильно: 00:01:06:13
   Неправильно: 01:06:13 (пропущены часы)

---
Формат ответа:
---

**[НАЧАЛО ЛОГОТИПА] - [КОНЕЦ ЛОГОТИПА]**
План: НДП
Содержание: Логотип. [Название студии/канала].
Диалоги: Музыка

**[КОНЕЦ ЛОГОТИПА] - [КОНЕЦ ЗАСТАВКИ — где начинается первый диалог]**
План: Ср. НДП
Содержание: Заставка. [Опиши всё что видишь: лица персонажей, их действия, предметы, визуальный стиль]
Титр: [Каждый титр на новой строке — имена актёров, режиссёров, продюсеров]
Название: [Название фильма/сериала если есть]
Диалоги: Музыка

**[КОНЕЦ ЗАСТАВКИ] - [следующая склейка]**
План: [Кр./Ср./Общ.] [+ НДП если есть титры]
Содержание: [Первая сцена с диалогом — опиши действие]
Диалоги: [ИМЯ ПЕРСОНАЖА]
[Первая реплика]

... далее каждая склейка = отдельный план ...

---
Неправильно (не делай так):
---

- Описывать каждую склейку заставки отдельно
- Заканчивать заставку там, где ещё нет диалогов
- Планы типа "Сюзанна улыбается", "Бэлла с веревками" — если это ещё заставка, объедини всё в один план

Как понять что заставка ещё идёт:
- Слышна только музыка заставки?
- Есть титры с именами?
- Персонажи "позируют" а не взаимодействуют?
- Это всё ещё заставка, не разбивай

---
Правила:
---

1. Объединяй заставку в один план (от логотипа до первого диалога).

2. Диалоги — каждая реплика с именем:
   ТОМА
   Проходите, присаживайтесь.

3. Короткие реплики — не пропускай! ("Что?", "Ага", "Да")

4. Имена — короткие формы:
   - ГАЛЯ (не "Галина"), ТАНЯ (не "Татьяна")
   - ТОМА, БЭЛЛА, ШУРОЧКА, ЛЮДАСЯ — как в списке

5. Запрещено:
   - [Шаги], [Вздох], [Шум] — не пиши
   - Если нет речи — просто "Музыка"

6. Тип плана для заставки: Нарезка или Ср. НДП (много коротких кадров)

Ожидаемая структура:
   - План 1: Логотип (несколько секунд)
   - План 2: Заставка (пока не начнётся первый диалог) — все титры и лица в одном плане
   - Планы 3+: Обычные планы (каждая склейка после начала диалогов)
   
Количество планов зависит от длины заставки — определи её визуально.`;
}

/**
 * Промпт для чанка с контекстом
 */
export function createChunkPromptV4(
  scenes: Array<{ start_timecode: string; end_timecode: string }>,
  chunkIndex: number,
  totalChunks: number,
  isFirstChunk: boolean,
  isLastChunk: boolean,
  characterRegistry: string = ''
): string {
  // Для первого чанка используем специальный промпт
  if (isFirstChunk && chunkIndex === 0) {
    return createOpeningPromptV4(scenes, characterRegistry);
  }
  
  // Для обычных чанков — стандартный промпт
  let prompt = createPromptV4(scenes, characterRegistry);
  
  // Добавляем информацию о позиции
  if (totalChunks > 1) {
    prompt += `\n\nЭто часть ${chunkIndex + 1} из ${totalChunks}.`;
  }
  
  // Для последнего чанка добавляем инструкцию про титры
  if (isLastChunk) {
    prompt += `\n\nВнимание: это последняя часть видео.
Если в конце есть титры (режиссёр, продюсер, оператор, актёры и т.д.):
- Объедини все титры в один план НДП
- Укажи тип плана: НДП
- В содержании напиши: Титры
- Перечисли все должности и имена из титров
- Диалоги: Музыка`;
  }
  
  return prompt;
}

/**
 * Нормализует таймкод в формат HH:MM:SS:FF
 * Исправляет частую ошибку AI: 01:06:13:00 → 00:01:06:13
 */
function normalizeTimecode(tc: string): string {
  if (!tc) return tc;
  
  const parts = tc.split(':');
  if (parts.length !== 4) return tc;
  
  const [p0, p1, p2, p3] = parts.map(Number);
  
  // Если первая часть > 0 но < 60, и это явно не часы,
  // то AI скорее всего написал MM:SS:FF:00 вместо 00:MM:SS:FF
  if (p0 > 0 && p0 < 60 && p3 === 0) {
    if (p1 >= 0 && p1 < 60 && p2 >= 0 && p2 < 30) {
      const corrected = `00:${String(p0).padStart(2, '0')}:${String(p1).padStart(2, '0')}:${String(p2).padStart(2, '0')}`;
      console.log(`   Timecode fix: ${tc} → ${corrected}`);
      return corrected;
    }
  }
  
  return tc;
}

/**
 * Парсер ответа v4 — markdown формат
 */
export function parseResponseV4(response: string): Array<{
  start_timecode: string;
  end_timecode: string;
  plan_type: string;
  description: string;
  dialogues: string;
}> {
  const results: Array<{
    start_timecode: string;
    end_timecode: string;
    plan_type: string;
    description: string;
    dialogues: string;
  }> = [];
  
  // Разбиваем по блокам, начинающимся с **таймкод - таймкод**
  const blocks = response.split(/\*\*(\d{2}:\d{2}:\d{2}(?::\d{2})?)\s*[-–—]\s*(\d{2}:\d{2}:\d{2}(?::\d{2})?)\*\*/);
  
  for (let i = 1; i < blocks.length; i += 3) {
    let startTimecode = blocks[i];
    let endTimecode = blocks[i + 1];
    const content = blocks[i + 2] || '';
    
    // Нормализуем таймкоды — добавляем :00 кадров если нет
    if (startTimecode && startTimecode.split(':').length === 3) {
      startTimecode += ':00';
    }
    if (endTimecode && endTimecode.split(':').length === 3) {
      endTimecode += ':00';
    }
    
    // Исправляем короткий формат
    startTimecode = normalizeTimecode(startTimecode);
    endTimecode = normalizeTimecode(endTimecode);
    
    if (!startTimecode || !endTimecode) continue;
    
    // Парсим содержимое блока
    const planMatch = content.match(/План:\s*(.+?)(?:\n|$)/i);
    const contentMatch = content.match(/Содержание:\s*([\s\S]*?)(?=Диалоги:|$)/i);
    const dialoguesMatch = content.match(/Диалоги:\s*([\s\S]*?)(?=\*\*|$)/i);
    
    results.push({
      start_timecode: startTimecode.trim(),
      end_timecode: endTimecode.trim(),
      plan_type: planMatch ? planMatch[1].trim() : 'Ср.',
      description: contentMatch ? contentMatch[1].trim() : '',
      dialogues: dialoguesMatch ? dialoguesMatch[1].trim() : 'Музыка',
    });
  }
  
  return results;
}
